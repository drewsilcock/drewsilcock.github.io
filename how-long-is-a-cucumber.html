<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- Canonical link, apparently needed for https -->
  <link rel="canonical" href="https://www.drewsilcock.co.uk/how-long-is-a-cucumber" />

  <title>
    
      How long is a cucumber? ü•í &middot; Drew Silcock
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/stylesheets.css">

  <!-- Google Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/public/media/icons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/public/media/icons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/media/icons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/public/media/icons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/public/media/icons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/public/media/icons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/media/icons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/public/media/icons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/public/media/icons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/public/media/icons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/public/media/icons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/public/media/icons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/public/media/icons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/public/media/icons/manifest.json">
  <link rel="mask-icon" href="/public/media/icons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/public/media/icons/mstile-144x144.png">
  <meta name="theme-color" content="#ac4142">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52653050-1', 'auto');
  ga('send', 'pageview');

</script>


  <body class="theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Nebulous Thoughts</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/archive/">Archive</a>
        
      
    
      
    
      
        
          <a class="sidebar-nav-item" href="/download/">Download</a>
        
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/projects/">Projects</a>
        
      
    
      
        
      
    
      
    
      
        
      
    

    <a class="sidebar-nav-item" href="https://github.com/drewsberry">GitHub Profile</a>
    <span class="sidebar-nav-item">Currently v1.2.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Drew Silcock</a>
            <small>new Stream(consciousness)</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">How long is a cucumber? ü•í</h1>
  <span class="post-meta">
      <span class="post-date">
          20 Dec 2018
      </span>
      <div class="post-meta-separator">
          &#x2016;
      </div>
      <span class="post-categories">
          <a href="/archive/#coding">
              Coding
          </a>
      </span>
  </span>
  <p><em>Or: UTF-16 handling of astral planes and implications for JavaScript string indexing</em></p>

<p><strong>tldr</strong>: 2.</p>

<p>String encoding in JavaScript is a bit weird. You might‚Äôve heard this before. You might even have read about how, somewhat inexplicably, JavaScript does not use the almost universal UTF-8 file encoding but instead UTF-16 (<a href="#note-1">see note 1</a>). In this article I‚Äôm going to explore some of the more subtle and perplexing aspects of the weird way JavaScript encodes its strings, what this means for common operations like string indexing and go on to discuss how other languages handle the same problems.</p>

<h2 id="so-whats-all-this-unicode-stuff-about-then">So what‚Äôs all this Unicode stuff about then?</h2>

<p><em>(If you‚Äôre already a Unicode wizard, go ahead and skip to the <a href="#so-what-does-this-have-to-do-with-javascript-and-cucumbers">next section</a>.)</em></p>

<p>Well, Unicode is a standard for defining characters like ‚ÄòF‚Äô, ‚Äò‚ô°‚Äô or ‚Äòü•í ‚Äò. (if you all you see is a blank box for this, just mentally replace it with another character like ‚ò∏). The way it does this is by giving each character a corresponding ‚Äò‚Äòcode point‚Äô‚Äô which is a numerical value like <code>135</code> (which happens to be this character: ‚Ä°). Usually, this numerical value is represented hexademically, meaning ‚Ä° corresponds to code point <code>0x87</code>.</p>

<p>The Unicode standard has a total of 1,114,112 code points, corresponding to 1,114,112 possible characters (the number of practically available characters is smaller than this, <a href="#note-2">see note 2</a> for why this is). That‚Äôs a lot of characters! To split this up, this space is divided into 17 ‚Äò‚Äòplanes‚Äô‚Äô, where each plane has 65,536 (or 2<sup>16</sup>) code points. The first plane, which contains most of the commonly used characters like ‚Äò‚Äò9‚Äô‚Äô, ‚Äò‚Äò¬£‚Äô‚Äô, ‚Äò‚Äò⁄û‚Äô‚Äô and ‚Äò‚Äò‰∏ß‚Äô‚Äô, is called the Basic Multilingual Plane (or BMP). This contains all of ASCII and extended ASCII; African, Middle-Eastern and non-Latin European scripts; Chinese, Japanese and Korean characters (collectively referred to as CJK characters); private use and what are known as ‚Äò‚Äòsurrogate pairs‚Äô‚Äô. I‚Äôll come onto what exactly surrogate pairs are used for a bit later.</p>

<p>Past this continent of common characters lies the vast, largely uninhabited and mysterious realms known as the 16 ‚Äò‚Äòastral planes‚Äô‚Äô (or ‚Äò‚Äòsupplementary planes‚Äô‚Äô, if you‚Äôre being boring).</p>

<p>The BMP takes up the first 2<sup>16</sup> code points in the range <code>0x0000</code> to <code>0xffff</code>. This means that all BMP code points can be represented using only 16 bits or 2 bytes (some fewer). The astral planes, extending from <code>0x10000</code> to the full <code>0x10ffff</code>, need between 3 and 4 bytes to represent them.</p>

<p><img src="/public/media/how-long-is-a-cucumber/astral_planes.jpg" alt="The 14&lt;sup&gt;th&lt;/sup&gt; Century philosopher Nicole Oresmo's astral planes." /></p>

<blockquote>
  <p>The 14<sup>th</sup> Century philosopher Nicole Oresmo demonstrates some astral plane characters. Images such as these would be distributed to the monks of the monasteries to aid their copying of Unicode manuscripts.</p>
</blockquote>

<h3 id="so-what-does-this-have-to-do-with-javascript-and-cucumbers">So what does this have to do with JavaScript and cucumbers?</h3>

<p>Well, among the vast expanse of astral code points lies the cucumber, code point <code>0x1f952</code>: ü•í . Because the cucumber character is above the BMP, it needsmore than 16 bits to represent it. Yet, JavaScript uses UTF-16 which encodes each character using only <em>16</em> bits, so how does this work?!</p>

<p>The truth is that UTF-16 essentially uses two separate code points to represent this single character. This is where the ‚Äò‚Äòsurrogate‚Äô‚Äô code points that I mentioned earlier come in. Unicode reserves two blocks, the ‚Äò‚ÄòHigh Surrogates‚Äô‚Äô: <code>0xd800</code> - <code>0xdbff</code> and the ‚Äò‚ÄòLow Surrogates‚Äô‚Äô: <code>0xdc00</code> - <code>0xdfff</code>.</p>

<p>Each astral code point is represented in UTF-16 as one Low Surrogate and one High Surrogate by the following equation:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><a name="True-1"></a><span class="mh">0x1000016</span> <span class="o">+</span> <span class="p">(</span><span class="nx">high_surrogate</span> <span class="err">‚àí</span> <span class="mh">0xd80016</span><span class="p">)</span> <span class="err">√ó</span> <span class="mh">0x40016</span> <span class="o">+</span> <span class="p">(</span><span class="nx">low_surrogate</span> <span class="err">‚àí</span> <span class="mh">0xdc0016</span><span class="p">)</span></code></pre></figure>

<p>What this means is that, in JavaScript, the cucumber character <code>0x1f952</code> is represented as <em>two separate codepoints</em>: <code>55358</code> or <code>0xd83e</code> (the high surrogate) and <code>56658</code> or <code>0xdd52</code> (the low surrogate).</p>

<h3 id="okay-so-what-does-this-mean-for-string-indexing">Okay, so what does this mean for string indexing?</h3>

<p>The astute reader may wonder what these surrogate pair representations of single characters means for the indexing of strings in JavaScript. When you have a string like <code>var s = "hello there"</code>, you expect <code>s[0]</code> to give you the first character, <code>s[3]</code> to give you the fourth character and <code>s[7]</code> to give you the eight character. But what about the following code:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><a name="True-1"></a><span class="kd">var</span> <span class="nx">cucumber</span> <span class="o">=</span> <span class="s2">&quot;ü•í&quot;</span><span class="p">;</span>
<a name="True-2"></a><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cucumber</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<a name="True-3"></a><span class="c1">// -&gt; 2</span></code></pre></figure>

<p>So, even though it contains only a single character, JavaScript thinks that the cucumber string has a length of 2! We can delve a bit further:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><a name="True-1"></a><span class="kd">var</span> <span class="nx">highSurrogate</span> <span class="o">=</span> <span class="nx">cucumber</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<a name="True-2"></a><span class="kd">var</span> <span class="nx">lowSurrogate</span> <span class="o">=</span> <span class="nx">cucumber</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<a name="True-3"></a>
<a name="True-4"></a><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">highSurrogate</span><span class="p">,</span> <span class="nx">highSurrogate</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">());</span>
<a name="True-5"></a><span class="c1">// -&gt; ÔøΩ 55358</span>
<a name="True-6"></a><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">lowSurrogate</span><span class="p">,</span> <span class="nx">lowSurrogate</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">());</span>
<a name="True-7"></a><span class="c1">// -&gt; ÔøΩ 56658</span></code></pre></figure>

<p>What this shows is that string indexing works by assuming that all characters are within the BMP, and so are exactly 16 bits long. So the indexing picks out not the entire cucumber character, but only one of its two surrogate pairs!</p>

<p>This means that the string indexing works the same way as classical C-like array indexing, where <code>s[4]</code> just means getting the address of <code>s</code> and skipping forward <code>4 * sizeof s[0]</code> bytes.</p>

<p>This maintains the O(1) speed of normal BMP string indexing, but is clearly bound to cause bugs when users are able to input astral characters into a script not expecting it! In fact, as I type out this article on http://dillinger.io, trying to remove an astral character with the ‚Äò‚ÄòDelete‚Äô‚Äô or ‚Äò‚ÄòBackspace‚Äô‚Äô buttons on a character like ‚Äò‚Äòüòä‚Äô‚Äô deletes not the character, but one of the <em>surrogates</em>, leaving the other surrogate as a weird question mark (ÔøΩ) which really confuses the cursor positioning‚Ä¶</p>

<p>It‚Äôs also a fun way to trick password forms into accepting fewer characters than they were asking for, like ‚Äò‚ÄòüòÇüòºüòä‚úåÔ∏è‚Äô‚Äô which will trick JavaScript minimum character checks looking for a minimum of 8 characters. (This string does have a length of 8, but not quite for the reason you might think - <a href="#note-3">see note X</a> for why this is.)</p>

<p>The reason that this result is so counter-intuitive and unhelpful is that the underlying encoding used is not <em>relevant</em> to the programmer using Unicode strings. There‚Äôs two separate layers of abstraction here which are being muddled thanks to indexing (and by extension iteration) giving you the underlying Unicode implementation-specific codepoint instead of the value that the programmer actually wants (and probably expects‚Ä¶)!</p>

<h3 id="what-about-this-utf-8-business-then">What about this UTF-8 business then?</h3>

<p>UTF-8 is a fully variable-length encoding, which means that there are no surrogate pairs necessary; ASCII character are only 1 byte long, but Arabic characters are 2 bytes long and the CJK characters are 3 bytes long. The astral code points extend from 3 to 4 bytes. UTF-16 is also not fixed size, but this is a more subtle point as it is only into the astral planes for the more obscure code points that multiple UTF-16 requires the variable length.</p>

<p>UTF-8 strings are always smaller (or same size as) UTF-16 or UTF-32 strings, which makes them the most compact Unicode encoding.</p>

<p>Another benefit of UTF-8 (and this applies to UTF-32 as well) is that because you don‚Äôt need to reserve a bunch of values for the surrogates we talked about earlier, you can actually include a <em>bunch</em> more actual characters. Unfortunately, as UTF-16 is so widely used those codepoints <em>have</em> to be reserved for surrogate use, even if it means they‚Äôre wasted in UTF-8 and UTF-32.</p>

<h3 id="so-how-do-other-languages-handle-unicode">So how do other languages handle Unicode?</h3>

<p>Well, JavaScript isn‚Äôt on its own:</p>

<ul>
  <li><strong>C</strong> - The standard types used are <code>char</code> which is generally used as an 8-bit character for ASCII (and sometimes for other purposes where <code>uint8_t</code> should <em>really</em> be used instead) and <code>wchar_t</code> (introduced in C90) for handling any Unicode code point. In truth, the standard does not specify the size of either <code>char</code> or <code>wchar_t</code> <a href="#note-4">See note 3 for more information about this</a>.</li>
  <li><strong>C++</strong> - natively uses 8-bit <code>std::string</code> much like pure C. There is <code>std::wstring</code> analogous to C‚Äôs <code>wchar_t</code> with corresponding <code>std::wcout</code>, <code>std::wcerr</code>, etc.</li>
  <li><strong>Python</strong> - I‚Äôm not going to open this can of worms. To summarise, Python supports the full Unicode range via either UTF-16 (as per JavaScript) or UCS-4 which is where each character is 32-bits long and you don‚Äôt have to deal with any of this surrogate nonsense (although all your strings end of being <em>much</em> larger than they need to be). As per usual with Python, all of these details are handles under the hood without the programmer needing to know any of the details. There are differences relating to Python 2.x vs 3.x and compile-time flags and all this confusing mess, but you can happily code away without worrying about it.</li>
  <li><strong>Java</strong> - Java‚Äôs <code>char</code> type is 16-bit length able to store the BMP characters only. The <code>String</code> type uses UTF-16 to enable the full Unicode range as per JavaScript.</li>
</ul>

<p>Then again, some of the newer languages seem to have seen the errors of the past and are adapting UTF-8 for strings natively:</p>

<ul>
  <li><strong>Go</strong> - Go source code is formatted as UTF-8. Strings are actually encoding-independent slices of bytes, however as Go source code is UTF-8 this practically means that almost all string literals are UTF-8. Indexing does <em>not</em>, however, index into the <em>codepoints</em> but the <em>bytes</em>. Bit weird, but there you go! See <a href="https://blog.golang.org/strings">golang.org</a> for more information on strings in Go.</li>
  <li><strong>D</strong> - has standard library support for UTF-8, UTF-16 <em>and</em> UTF-32 via <code>string</code>, <code>wstring</code> and <code>dstring</code> respectively, so you‚Äôre spoilt for choice!</li>
  <li><strong>Rust</strong> - uses UTF-8 strings as standard - Rust source code is UTF-8, string literals are UTF-8, the <code>std::string::String</code> encapsulates a UTF-8 string and primitive type <code>str</code> (the borrowed counterpart to <code>std::string::String</code>) is always valid UTF-8. Nice!</li>
</ul>

<p>Check <a href="https://unicodebook.readthedocs.io/programming_languages.html">this link</a> out for more information about how different programming languages handle Unicode.</p>

<h3 id="bonus-round-utf-8-string-indexing-in-rust">Bonus round: UTF-8 string indexing in Rust</h3>

<p>While languages like Go embrace UTF-8 but maintain indexing into bytes as the default, Rust goes even further in enforcing a UTF-8 treatment of all strings. So what happens when you try to index strings in Rust?</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><a name="True-1"></a>  <span class="o">|</span>
<a name="True-2"></a><span class="mi">5</span> <span class="o">|</span>     <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Normal[5]: &#39;{}&#39;&quot;</span><span class="p">,</span> <span class="n">normal_string</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<a name="True-3"></a>  <span class="o">|</span>                                 <span class="o">^^^^^^^^^^^^^^^^</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">String</span><span class="err">`</span> <span class="n">cannot</span> <span class="kr">be</span> <span class="n">indexed</span> <span class="n">by</span> <span class="err">`</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="err">`</span>
<a name="True-4"></a>  <span class="o">|</span>
<a name="True-5"></a>  <span class="o">=</span> <span class="n">help</span><span class="o">:</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">ops</span><span class="o">::</span><span class="nb">Index</span><span class="o">&lt;</span><span class="p">{</span><span class="n">integer</span><span class="p">}</span><span class="o">&gt;</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">String</span><span class="err">`</span></code></pre></figure>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=25af3779c35a7dfc4a147e943015c9f3">(Try it out)</a></p>

<p>In fact, Rust prevent indexing into strings using the normal <code>[idx]</code> syntax <em>entirely</em> on the basis that</p>

<p>a. It‚Äôs not clear whether indexing should work on bytes, code points or grapheme clusters.
b. Using the <code>[idx]</code> indexing syntax mentally implies O(1) execution, which won‚Äôt be the case for either code point or grapheme indexing.</p>

<p>Instead, Rust forces you to choose which to index into by providing two iterators:</p>

<ul>
  <li><code>my_string.bytes()</code> for iterating over raw bytes - each item is given as a <code>u8</code>.</li>
  <li><code>my_string.chars()</code> for iterating over code points (technically it is for iterating over <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Values</a> which is basically a Unicode code point excluding the low and high surrogates discussed earlier) - each item is given as a <code>char</code>, which is a 32-bit long representation of a single codepoint.</li>
</ul>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><a name="True-1"></a><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="kd">let</span> <span class="n">normal_string</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;UTF-8! ü•í&quot;</span><span class="p">);</span>
<a name="True-3"></a>
<a name="True-4"></a>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Here&#39;s my normal UTF-8 string: &#39;{}&#39;&quot;</span><span class="p">,</span> <span class="n">normal_string</span><span class="p">);</span>
<a name="True-5"></a>
<a name="True-6"></a>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Here&#39;s the chars iterator:&quot;</span><span class="p">);</span>
<a name="True-7"></a>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;--------------------------&quot;</span><span class="p">);</span>
<a name="True-8"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">in</span> <span class="n">normal_string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span> <span class="p">{</span>
<a name="True-9"></a>        <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;char at index {}: {}&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<a name="True-10"></a>    <span class="p">}</span>
<a name="True-11"></a>
<a name="True-12"></a>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Here&#39;s the bytes iterator:&quot;</span><span class="p">);</span>
<a name="True-13"></a>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;--------------------------&quot;</span><span class="p">);</span>
<a name="True-14"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="n">normal_string</span><span class="p">.</span><span class="n">bytes</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span> <span class="p">{</span>
<a name="True-15"></a>        <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;byte at index {}: {} ({})&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">char</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<a name="True-16"></a>    <span class="p">}</span>
<a name="True-17"></a><span class="p">}</span>
<a name="True-18"></a>
<a name="True-19"></a><span class="c1">// Here&#39;s my normal UTF-8 string: &#39;UTF-8! ü•í&#39;</span>
<a name="True-20"></a><span class="c1">//</span>
<a name="True-21"></a><span class="c1">// Here&#39;s the chars iterator:</span>
<a name="True-22"></a><span class="c1">// --------------------------</span>
<a name="True-23"></a><span class="c1">// char at index 0: U</span>
<a name="True-24"></a><span class="c1">// char at index 1: T</span>
<a name="True-25"></a><span class="c1">// char at index 2: F</span>
<a name="True-26"></a><span class="c1">// char at index 3: -</span>
<a name="True-27"></a><span class="c1">// char at index 4: 8</span>
<a name="True-28"></a><span class="c1">// char at index 5: !</span>
<a name="True-29"></a><span class="c1">// char at index 6:  </span>
<a name="True-30"></a><span class="c1">// char at index 7: ü•í</span>
<a name="True-31"></a><span class="c1">//</span>
<a name="True-32"></a><span class="c1">// Here&#39;s the bytes iterator:</span>
<a name="True-33"></a><span class="c1">// --------------------------</span>
<a name="True-34"></a><span class="c1">// byte at index 0: 85 (U)</span>
<a name="True-35"></a><span class="c1">// byte at index 1: 84 (T)</span>
<a name="True-36"></a><span class="c1">// byte at index 2: 70 (F)</span>
<a name="True-37"></a><span class="c1">// byte at index 3: 45 (-)</span>
<a name="True-38"></a><span class="c1">// byte at index 4: 56 (8)</span>
<a name="True-39"></a><span class="c1">// byte at index 5: 33 (!)</span>
<a name="True-40"></a><span class="c1">// byte at index 6: 32 ( )</span>
<a name="True-41"></a><span class="c1">// byte at index 7: 240 (√∞)</span>
<a name="True-42"></a><span class="c1">// byte at index 8: 159 (¬ü)</span>
<a name="True-43"></a><span class="c1">// byte at index 9: 165 (¬•)</span>
<a name="True-44"></a><span class="c1">// byte at index 10: 146 (¬í)</span></code></pre></figure>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ac4dfbe2ebd3788954a7cce5e278ca5e">(Try it out)</a></p>

<p>You might notice that Rust doesn‚Äôt provide a standard library way of iterating through grapheme clusters, although there are <a href="https://crates.io/crates/unicode-segmentation">crates that do exactly this</a>. This might give you an idea of just how complicated this Unicode malarkey can get if you keep digging.</p>

<p>This means that Rust eschews the traditional string O(1) indexing. The pro of this is that you get out of it what you actually <em>want</em>, which is the n<sup>th</sup> visible rune instead of the n<sup>th</sup> byte or 16-bit char. The con is that we lose our O(1) speed string indexing as we now have to look through each previous character to check the length before we get to our rune at n, making lookup O(n).</p>

<p><img src="/public/media/how-long-is-a-cucumber/string_encoding_visual.png" alt="A comparison of how UTF-16 and UTF-8 index strings." /></p>

<blockquote>
  <p>A visualisation of how UTF-16 constructs strings compared to UTF-8. The resulting UTF-8 string is shorter, but indexing is not O(n) (as opposed to O(1)) due to the multi-byte nature of the UTF-8 character.</p>
</blockquote>

<h3 id="aside-private-use-in-unicode">Aside: private use in Unicode</h3>

<p>What do you see when you look at the following symbol: ‚ÄòÓÄÄ‚Äô?</p>

<p>Some people will see a weird ‚Äòp‚Äô-like symbol. On Linux, you might see a tiny Tux, the friendly Linux mascot: <img src="public/media/how-long-is-a-cucumber/tux.png" alt="Tux" /></p>

<p>That‚Äôs because it‚Äôs part of the ‚ÄúPrivate Use Areas‚Äù of the Unicode standard. This means that these codepoints, <em>by definition</em>, will never have any characters assigned to them by the Unicode Consortium.</p>

<h3 id="notes">Notes</h3>

<h4 id="note-1">Note 1</h4>

<p>Technically, the <a href="http://es5.github.io/x2.html#x2">ECMAScript 5 specification</a> with which JavaScript is compliant specifies <em>either</em> UCS-2 <em>or</em> UTF-16 for string encoding, but we won‚Äôt delve into this too much here. For more information on this subtle distinction, go read <a href="https://mathiasbynens.be/notes/javascript-encoding">this article</a>, it‚Äôs a really interesting read and I‚Äôd very much recommend it if you enjoy reading this post.</p>

<p><a href="#">Back to text</a></p>

<h4 id="note-2">Note 2</h4>

<p>In fact, the actual number of characters is significantly smaller than this for a few reasons:</p>

<ul>
  <li>137,468 code points are for ‚Äò‚Äòprivate use‚Äô‚Äô, meaning they will by definition never be assigned values by the Unicode Consortium.</li>
  <li>2,048 code points are used as ‚Äò‚Äòsurrogates‚Äô‚Äô. I‚Äôll discuss surrogates when it comes to UTF-16 in JavaScript later in this article.</li>
  <li>66 code points are specified as non-characters and used internally by programs. For example, the assigned non-character <code>0xfffe</code> is used by programs to check whether they‚Äôve got the endianness of a text file right, because the endian complement to <code>0xfffe</code> is <code>0xfeff</code>, which is the Byte Order Mark (BOM). If a program encounters <code>0xfffe</code> at the start of a file, they it knows that they‚Äôve got the endianess the wrong way around, because <code>0xfffe</code> is <em>guaranteed</em> not to be used by the file as a character.</li>
</ul>

<p>This means that there are 1,111,998 possible characters, of which 974,530 characters are <em>available</em> for allocation.</p>

<p>As of Unicode 11.0 (released June 2018), there are 137,439 Unicode codepoints that have assigned values. This graph shows how the Unicode Consortium has assigned codepoints throughout its history:</p>

<p><img src="/public/media/how-long-is-a-cucumber/unicode_through_the_ages.svg" alt="Plot showing Unicode codepoints assigned over time" /></p>

<p>As you can see, they‚Äôve still got a lot of possible codepoints to choose from!</p>

<p><a href="#so-whats-all-this-unicode-stuff-about-then">Back to text</a></p>

<h4 id="note-3">Note 3</h4>

<p>In fact, the last symbol in that array - ‚úåÔ∏è - also known as ‚Äúvictory hand‚Äù, is within the BMP. So why does it appear as an emoji with length 2? Why, that‚Äôs an excellent question. To see what‚Äôs going on here, let‚Äôs break down how JavaScript sees the character:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><a name="True-1"></a><span class="kr">const</span> <span class="nx">victory_hand</span> <span class="o">=</span> <span class="s2">&quot;‚úåÔ∏è&quot;</span><span class="p">;</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="True-4"></a><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">c</span> <span class="nx">of</span> <span class="nx">victory_hand</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;%d: %s U+%s&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">codePointAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
<a name="True-6"></a>    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<a name="True-7"></a><span class="p">}</span>
<a name="True-8"></a>
<a name="True-9"></a><span class="c1">// Returns:</span>
<a name="True-10"></a><span class="c1">// 0: ‚úå U+270c</span>
<a name="True-11"></a><span class="c1">// 1: Ô∏è U+fe0f</span></code></pre></figure>

<p>The first character is the victory hand symbol U+270c (i.e. Unicode codepoint 0x270c) that we were expecting, but what is this second codepoint, the U+fe0f?</p>

<p>This U+fe0f codepoint is known as ‚Äúvariation selector-16‚Äù (i.e. the 16<sup>th</sup> codepoint within the ‚Äúvariation selector‚Äù range. What it does is tell the text rendering system to render the previous character not as a black-and-white normal text character but as a colourful graphical character - the emoji that we actually see.</p>

<p>In the parlance of Unicode, the BMP victory hand and the variation selector-16 together form a ‚Äú<em>grapheme cluster</em>‚Äù, meaning that both codepoints together form the graphical character seen on screen.</p>

<p><a href="https://tsibley.github.io/tchrist-OSCON2011-Unicode/gbu.html">This presentation</a> - ‚ÄúUnicode: Good, Bad and Ugly‚Äù - has a really thorough explanation of graphemes and the different complications around them, along with how they‚Äôre handled in various languages.</p>

<p><a href="#so-what-does-this-have-to-do-with-javascript-and-cucumbers">Back to text</a></p>

<h4 id="note-4">Note 4</h4>

<p>C90 defines <code>wchar_t</code> as ‚Äúan integral type whose range of values can represent distinct codes for all members of the largest extended character set specified among the supported locales‚Äù (ISO 9899:1990 ¬ß4.1.5).</p>

<p>This is a classic example of C specifications not really giving away enough details to really nail down an API, which is one of the reasons that undefined behaviour is <em>so easy</em> to accidentally stumble upon in C. Classic examples of under-defined standards in C is that <code>char</code> need not be 8 bits long, <code>int</code> not needing to be 16 bits long, <code>double</code> not needing to be 4 bytes - all of these are left up to the compiler to implement.</p>

<p><a href="#so-how-do-other-languages-handle-unicode">Back to text</a></p>

<h2 id="updates-and-corrections">Updates and Corrections</h2>

<p><strong>2018-12-27</strong> - Several points updated, rephrased and explanations clarified followed some interesting comments on <a href="https://lobste.rs/s/dxfgql/how_long_is_cucumber">Lobsters</a>.</p>

<ul>
  <li>The number of code points in a simple Unicode plane is 65,536 not 65,535 as stated previously (thanks to /u/Nayuki for pointing this mistake out).</li>
  <li>Explanation of Rust indexing was updated to clarify that both byte-indexing and codepoint-indexing is possible, but neither using the native indexing syntax (thanks to /u/Nayuki and /u/Kyrias for clarifying this).</li>
  <li>CJK characters are in the 3-byte range in UTF-8, not the 2-byte range as previously stated (thanks to /u/Nayuki for pointing this mistake out).</li>
  <li>The C standard is far more vague than I initially understood in defining <code>char</code> and <code>wchar_t</code>. Post updated to reflect this (thanks to /u/tedu and /u/notriddle for explaining this).</li>
  <li>Added graph depicting assignment of codepoints by the Unicode Consortium.</li>
  <li>Lots of minor rephrasing and refactoring.</li>
</ul>

<p><strong>2018-12-30</strong> - Minor correction, additional explanation and note.</p>

<ul>
  <li>Added note on victory hand emoji and grapheme clusters (thanks to Lars Dieckow for explaining this, and for providing the code snippet and link included in the added note).</li>
  <li>The cucumber emoji is represented as two separate <em>codepoints</em>, not two separate <em>characters</em> as previously stated (thanks to Lars Dieckow for pointing this mistake out).</li>
  <li>Added additional note complaining about why string indexing giving UTF-16 codepoints is unhelpful.</li>
</ul>


</div>

<hr>
<p><form action="/">
  <button class="btn btn-default btn-lg" href="/">
      Back to home...
  </button>
</form></p>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/jekyll-katex-block">
            Jekyll KaTeX Block
            <small>04 Nov 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/using-make-and-latexmk">
            Using make and latexmk for easy LaTeX compilation
            <small>23 Sep 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/calculating-overlap">
            Calculating the overlap of aerial photos
            <small>31 Jul 2014</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>



    <!-- Message inviting everyone to comment -->
    <div class="discuss">
        If you liked this post, have any questions or fancy having a good discussion, please leave a comment below, or 
        <a href = "mailto:drewATdrewsilcockDOTcoDOTuk" 
           onclick = "this.href=this.href
                      .replace(/AT/,'&#64;')
                      .replace(/DOT/,'&#46;')
                      .replace(/DOT/,'&#46;')"
        >send me an email.</a>
    </div>

    <!-- Add Disqus comments -->
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'drewsilcock'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
 


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>

  </body>

</html>

